use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

fn main() {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let proto = manifest_dir.join("../../proto/message.proto");
    println!("cargo:rerun-if-changed={}", proto.display());

    prost_build::Config::new()
        .compile_protos(&[proto.as_path()], &[manifest_dir.join("../../proto")])
        .expect("Failed to compile .proto with prost-build");

    // Create a mod.rs in OUT_DIR that includes all generated .rs files
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set"));
    let mod_path = out_dir.join("mod.rs");
    let mut body = String::from("// @generated by build.rs\n");
    if let Ok(entries) = fs::read_dir(&out_dir) {
        for entry in entries.flatten() {
            let p = entry.path();
            if p.extension().and_then(|s| s.to_str()) == Some("rs") {
                if p.file_name().and_then(|s| s.to_str()) == Some("mod.rs") {
                    continue;
                }
                if let Some(name) = p.file_name().and_then(|s| s.to_str()) {
                    body.push_str(&format!(
                        "include!(concat!(env!(\"OUT_DIR\"), \"/{}\"));\n",
                        name
                    ));
                }
            }
        }
    }
    fs::write(&mod_path, body).expect("failed to write mod.rs");

    // Ensure the Nim static library is built and linkable when this crate is used as a dependency
    let nim_dir = manifest_dir.join("../../libnimdemo");
    println!("cargo:rerun-if-changed={}", nim_dir.join("src").display());

    // Build the Nim static lib via nimble (non-interactive)
    // If Nim isn't installed, this step will fail; in that case, build via CMake instead.
    let status = Command::new("nimble")
        .arg("buildlib")
        .arg("-y")
        .current_dir(&nim_dir)
        .status();
    match status {
        Ok(s) if s.success() => {}
        Ok(s) => panic!("nimble buildlib failed with status: {s}"),
        Err(e) => panic!("failed to invoke nimble: {e}"),
    }

    // Point the Rust linker at the Nim lib output directory
    let nim_build_dir = nim_dir.join("build");
    println!(
        "cargo:rustc-link-search=native={}",
        nim_build_dir.display()
    );
    // Link the static libnimdemo.a (library name is 'nimdemo')
    println!("cargo:rustc-link-lib=static=nimdemo");
}

use once_cell::sync::Lazy;
use parking_lot::RwLock;
use std::sync::Arc;
use std::collections::HashMap;
use std::ffi::CStr;
use std::os::raw::{c_char, c_int, c_void};
use std::ptr;

pub mod proto {
    // Generated by build.rs (prost-build)
    include!(concat!(env!("OUT_DIR"), "/mod.rs"));
}

pub mod api;

// C API from libnimdemo.h
extern "C" {
    // void requestApiCall(const char* req, void* argBuffer, int argLen);
    fn requestApiCall(req: *const c_char, arg_buffer: *mut c_void, arg_len: c_int);
    // void* allocateArgBuffer(int size);
    fn allocateArgBuffer(size: c_int) -> *mut c_void;
    // void deallocateArgBuffer(void* p);
    fn deallocateArgBuffer(p: *mut c_void);
    // Library lifecycle
    fn libnimdemo_initialize();
    fn libnimdemo_teardown();
}

// Registry for event handlers
// Handler receives ownership of arg_buffer (must free via deallocateArgBuffer)
type HandlerFn = Arc<dyn Fn(*mut c_void, usize) + Send + Sync + 'static>;
static HANDLERS: Lazy<RwLock<HashMap<String, HandlerFn>>> =
    Lazy::new(|| RwLock::new(HashMap::new()));

// Trait to map message types to event names (specialize per message type)
pub trait EventName {
    const NAME: &'static str;
}

// Register a typed handler with explicit event name
pub fn register_handler_named<M, F>(name: &str, cb: F)
where
    M: prost::Message + Default + 'static,
    F: Fn(&M) + Send + Sync + 'static,
{
    let name = name.to_string();
    let handler: HandlerFn = Arc::new(move |ptr_buf: *mut c_void, len: usize| {
        if ptr_buf.is_null() {
            return;
        }
        // Copy bytes then free producer-owned buffer
        let mut bytes = Vec::with_capacity(len);
        unsafe {
            bytes.set_len(len);
            ptr::copy_nonoverlapping(ptr_buf as *const u8, bytes.as_mut_ptr(), len);
            deallocateArgBuffer(ptr_buf);
        }
        match M::decode(bytes.as_slice()) {
            Ok(msg) => cb(&msg),
            Err(e) => {
                eprintln!("Rust> decode failed for {}: {e}", std::any::type_name::<M>());
            }
        }
    });

    HANDLERS.write().insert(name, handler);
}

// Register a typed handler using EventName mapping
pub fn register_handler<M, F>(cb: F)
where
    M: prost::Message + Default + EventName + 'static,
    F: Fn(&M) + Send + Sync + 'static,
{
    register_handler_named::<M, _>(M::NAME, cb);
}

// Initialize/teardown the underlying Nim library (must be called before use)
pub fn initialize() {
    unsafe { libnimdemo_initialize() }
}

pub fn teardown() {
    unsafe { libnimdemo_teardown() }
}

// Exported C symbol expected by libnimdemo to deliver events
#[no_mangle]
pub extern "C" fn dispatchEvent(event: *const c_char, arg_buffer: *mut c_void, arg_len: c_int) {
    let name = unsafe {
        if event.is_null() {
            ""
        } else {
            match CStr::from_ptr(event).to_str() {
                Ok(s) => s,
                Err(_) => "",
            }
        }
    }
    .to_string();

    let len = if arg_len < 0 { 0 } else { arg_len as usize };

    if let Some(handler) = HANDLERS.read().get(&name).cloned() {
        (handler)(arg_buffer, len);
    } else {
        // Avoid leaks on unknown events
        unsafe {
            if !arg_buffer.is_null() {
                deallocateArgBuffer(arg_buffer)
            }
        }
        eprintln!("Rust> no handler for event '{name}'");
    }
}

// Example specialization; uncomment and adjust when needed
impl EventName for proto::OnReceivedEvent {
    const NAME: &'static str = "onReceivedEvent";
}
